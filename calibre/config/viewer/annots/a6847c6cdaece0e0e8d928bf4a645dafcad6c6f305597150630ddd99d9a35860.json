[{"pos": "epubcfi(/22/2/4/2/42/1:261)", "pos_type": "epubcfi", "timestamp": "2022-10-07T11:33:56.196656+00:00", "type": "last-read"}, {"end_cfi": "/2/4/2/736/1:295", "highlighted_text": "The example gives some insight as to when using subclasses like this is useful. Here, I’ve moved the conditional lookup from two functions (amountFor and volumeCreditsFor) to a single constructor function createPerformanceCalculator. The more functions there are that depend on the same type of polymorphism, the more useful this approach becomes.", "spine_index": 9, "spine_name": "OEBPS/xhtml/ch01.xhtml", "start_cfi": "/2/4/2/736/1:0", "style": {"kind": "color", "type": "builtin", "which": "green"}, "timestamp": "2022-10-07T10:25:01.075Z", "toc_family_titles": ["Chapter 1 Refactoring: A First Example", "Status: Creating the Data with the Polymorphic Calculator"], "type": "highlight", "uuid": "9iZcLWF6WxC4_YgHTaNrLw"}, {"end_cfi": "/2/4/2/744/1:331", "highlighted_text": "communicate", "spine_index": 9, "spine_name": "OEBPS/xhtml/ch01.xhtml", "start_cfi": "/2/4/2/744/1:320", "style": {"kind": "color", "type": "builtin", "which": "purple"}, "timestamp": "2022-10-07T11:24:33.486Z", "toc_family_titles": ["Chapter 1 Refactoring: A First Example", "Final Thoughts"], "type": "highlight", "uuid": "ijgQwxdUISioVnuALmzlUw"}, {"end_cfi": "/2/4/2/746/1:249", "highlighted_text": " A common sequence is: Read the code, gain some insight, and use refactoring to move that insight from your head back into the code.", "spine_index": 9, "spine_name": "OEBPS/xhtml/ch01.xhtml", "start_cfi": "/2/4/2/746/1:117", "style": {"kind": "color", "type": "builtin", "which": "green"}, "timestamp": "2022-10-07T11:24:53.786Z", "toc_family_titles": ["Chapter 1 Refactoring: A First Example", "Final Thoughts"], "type": "highlight", "uuid": "KSp_eXwPXTeQnnEInKFg8A"}, {"end_cfi": "/2/4/2/746/1:374", "highlighted_text": " The clearer code then makes it easier to understand it, leading to deeper insights and a beneficial positive feedback loop. ", "spine_index": 9, "spine_name": "OEBPS/xhtml/ch01.xhtml", "start_cfi": "/2/4/2/746/1:249", "style": {"kind": "color", "type": "builtin", "which": "red"}, "timestamp": "2022-10-07T11:25:09.212Z", "toc_family_titles": ["Chapter 1 Refactoring: A First Example", "Final Thoughts"], "type": "highlight", "uuid": "g1QsYfujfTbjFvaSG_cpXw"}, {"end_cfi": "/2/4/2/752/2[page_44]:593", "highlighted_text": "But the most important thing to learn from this example is the rhythm of refactoring. Whenever I’ve shown people how I refactor, they are surprised by how small my steps are, each step leaving the code in a working state that compiles and passes its tests. I was just as surprised myself when Kent Beck showed me how to do this in a hotel room in Detroit two decades ago. The key to effective refactoring is recognizing that you go faster when you take tiny steps, the code is never broken, and you can compose those small steps into substantial changes. Remember that—and the rest is silence.", "notes": "the rest is silence...\n", "spine_index": 9, "spine_name": "OEBPS/xhtml/ch01.xhtml", "start_cfi": "/2/4/2/752/2[page_44]:0", "style": {"kind": "color", "type": "builtin", "which": "purple"}, "timestamp": "2022-10-07T11:26:58.911Z", "toc_family_titles": ["Chapter 1 Refactoring: A First Example", "Final Thoughts"], "type": "highlight", "uuid": "d3hohsXJ5J8MPv1DKBhqaA"}, {"removed": true, "timestamp": "2022-10-07T11:31:09.285Z", "type": "highlight", "uuid": "6Oc1AEgHYU8GMFZosNyt3Q"}, {"removed": true, "timestamp": "2022-10-07T11:30:54.283Z", "type": "highlight", "uuid": "1MEVsqmKlS_mt-8S1BQBDg"}, {"removed": true, "timestamp": "2022-10-07T11:30:54.284Z", "type": "highlight", "uuid": "_p1mxbKs85KhA5BtznbkHg"}, {"removed": true, "timestamp": "2022-10-07T11:30:54.284Z", "type": "highlight", "uuid": "OyPKMN0WUBYAW4peOvNMxw"}, {"removed": true, "timestamp": "2022-10-07T11:30:54.284Z", "type": "highlight", "uuid": "9BAHCssYPnRmOcDZ-Z3hIw"}, {"removed": true, "timestamp": "2022-10-07T11:30:54.284Z", "type": "highlight", "uuid": "SldFICxIrpz3J54za59f1Q"}, {"removed": true, "timestamp": "2022-10-07T11:30:54.284Z", "type": "highlight", "uuid": "cGENfnMhTHht2OYYQr2lLA"}, {"removed": true, "timestamp": "2022-10-07T11:30:54.284Z", "type": "highlight", "uuid": "nQmy4BMbXDAW0Y1RsZfSvg"}, {"removed": true, "timestamp": "2022-10-07T11:32:24.388Z", "type": "highlight", "uuid": "ykjyIzxrtagKtqimVVBx0A"}, {"end_cfi": "/2/4/2/24/1:433", "highlighted_text": "I don’t spend any time debugging", "spine_index": 10, "spine_name": "OEBPS/xhtml/ch02.xhtml", "start_cfi": "/2/4/2/24/1:401", "style": {"kind": "color", "type": "builtin", "which": "green"}, "timestamp": "2022-10-07T11:31:28.331Z", "toc_family_titles": ["Chapter 2 Principles in Refactoring", "Defining Refactoring"], "type": "highlight", "uuid": "0Eap40p1QUkVHUo4trpOQg"}, {"end_cfi": "/2/4/2/10/2:146", "highlighted_text": "observable ", "spine_index": 10, "spine_name": "OEBPS/xhtml/ch02.xhtml", "start_cfi": "/2/4/2/10/2:136", "style": {"kind": "color", "type": "builtin", "which": "purple"}, "timestamp": "2022-10-07T11:32:00.540Z", "toc_family_titles": ["Chapter 2 Principles in Refactoring", "Defining Refactoring"], "type": "highlight", "uuid": "P-iaHdKnQ5oiuBRE6K5lNg"}, {"end_cfi": "/2/4/2/10/2:92", "highlighted_text": "understand", "spine_index": 10, "spine_name": "OEBPS/xhtml/ch02.xhtml", "start_cfi": "/2/4/2/10/2:82", "style": {"kind": "color", "type": "builtin", "which": "red"}, "timestamp": "2022-10-07T11:32:08.482Z", "toc_family_titles": ["Chapter 2 Principles in Refactoring", "Defining Refactoring"], "type": "highlight", "uuid": "b8pR4WWAoajNO-6KuVQWPg"}, {"end_cfi": "/2/4/2/10/2:104", "highlighted_text": "cheaper", "spine_index": 10, "spine_name": "OEBPS/xhtml/ch02.xhtml", "start_cfi": "/2/4/2/10/2:97", "style": {"kind": "color", "type": "builtin", "which": "blue"}, "timestamp": "2022-10-07T11:32:12.440Z", "toc_family_titles": ["Chapter 2 Principles in Refactoring", "Defining Refactoring"], "type": "highlight", "uuid": "r_8bSeeKom7BWj5yyY3kag"}, {"end_cfi": "/2/4/2/28/1:337", "highlighted_text": "Refactoring is very similar to performance optimization, as both involve carrying out code manipulations that don’t change the overall functionality of the program. The difference is the purpose: Refactoring is always done to make the code “easier to understand and cheaper to modify.” This might speed things up or slow things down. Wit", "spine_index": 10, "spine_name": "OEBPS/xhtml/ch02.xhtml", "start_cfi": "/2/4/2/28/1:0", "style": {"kind": "color", "type": "builtin", "which": "red"}, "timestamp": "2022-10-07T11:32:34.136Z", "toc_family_titles": ["Chapter 2 Principles in Refactoring", "Defining Refactoring"], "type": "highlight", "uuid": "6ypStayuJqosuFEcJ0g6-w"}, {"end_cfi": "/2/4/2/28/1:515", "highlighted_text": "erformance optimization, I only care about speeding up the program, and am prepared to end up with code that is harder to work with if I really need that improved performance.", "spine_index": 10, "spine_name": "OEBPS/xhtml/ch02.xhtml", "start_cfi": "/2/4/2/28/1:340", "style": {"kind": "color", "type": "builtin", "which": "red"}, "timestamp": "2022-10-07T11:32:40.243Z", "toc_family_titles": ["Chapter 2 Principles in Refactoring", "Defining Refactoring"], "type": "highlight", "uuid": "umIUZdta8z99e7kT79R0LA"}, {"end_cfi": "/2/4/2/34/1:599", "highlighted_text": "Kent Beck came up with a metaphor of the two hats. When I use refactoring to develop software, I divide my time between two distinct activities: adding functionality and refactoring. When I add functionality, I shouldn’t be changing existing code; I’m just adding new capabilities. I measure my progress by adding tests and getting the tests to work. When I refactor, I make a point of not adding functionality; I only restructure the code. I don’t add any tests (unless I find a case I missed earlier); I only change tests when I have to accommodate a change in an interface.\n\nAs I develop software, I find myself swapping hats frequently. I start by trying to add a new capability, then I realize this would be much easier if the code were structured differently. So I swap hats and refactor for a while. Once the code is better structured, I swap hats back and add the new capability. Once I get the new capability working, I realize I coded it in a way that’s awkward to understand, so I swap hats again and refactor. All this might take only ten minutes, but during this time I’m always aware of which hat I’m wearing and the subtle difference that makes to how I program.", "notes": "hats analogy\n", "spine_index": 10, "spine_name": "OEBPS/xhtml/ch02.xhtml", "start_cfi": "/2/4/2/32/1:0", "style": {"kind": "color", "type": "builtin", "which": "purple"}, "timestamp": "2022-10-07T11:33:40.281Z", "toc_family_titles": ["Chapter 2 Principles in Refactoring", "The Two Hats"], "type": "highlight", "uuid": "aDB2tmEsRf0L8cRE3DfCqg"}]